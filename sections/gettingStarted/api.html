<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>Mooltipage - Getting Started - JS API</title><style>/** * Shared CSS for documentation project */ /* Standard color palette */ :root { /* Semantic colors */ --color-error: red; --color-warning: yellow; --color-success: green; --color-active: #0091ff; --color-alert: blue; --color-highlight: purple; --color-primary: black; --color-secondary: #4F4F4F; --color-light: white; /* Background colors */ --color-bg-content: white; --color-bg-isolate: #FAFAFA; --color-bg-shadow: lightgrey; --color-bg-aside: lightsteelblue; --color-bg-banner: skyblue; } /* Responsive layout tools */ :root { /* Switch to large when screen is at least 992px wide (bootstrap "large" breakpoint) */ --flow-breakpoint-small: 0px; --flow-breakpoint-large: 992px; --flow-flex-direction-small: row; --flow-flex-direction-large: column; --flow-padding-small: 10px; --flow-padding-large: 20px; /* Default all to small values */ --flow-flex-direction: var(--flow-flex-direction-small); --flow-flex-direction-inverse: var(--flow-flex-direction-large); --flow-padding: var(--flow-padding-small); --flow-padding-inverse: var(--flow-padding-large); } @media(min-width: 992px) { :root { --flow-flex-direction: var(--flow-flex-direction-large); --flow-flex-direction-inverse: var(--flow-flex-direction-small); --flow-padding: var(--flow-padding-large); --flow-padding-inverse: var(--flow-padding-small); } } * { box-sizing: border-box; font-family: Arial, Helvetica, sans-serif; line-height: 1.2; } .flex-spacer { flex: auto; } h1, h2, h3, h4, h5, h6, p, div, body, ul, ol { padding: 0; margin: 0; } h1 { font-size: 1.5rem; font-weight: bold; } h2 { font-size: 1.4rem; font-weight: bold; } h3 { font-size: 1.3rem; font-weight: bold; } h4 { font-size: 1.2rem; font-weight: bold; } h5 { font-size: 1.1rem; font-weight: bold; } p, h6, div { font-size: 1rem; font-weight: normal; } /* Make lists easier to style */ ul, ol { list-style-position: inside } /* Style links */ a { text-decoration: none; } a:link { color: var(--color-alert); } a:visited { color: var(--color-highlight); } a:hover { text-decoration: underline; } a.link-is-current-page { font-weight: bold; }</style><style>.responsive-flex-layout { display: flex; flex-wrap: nowrap; } .responsive-flex-layout[data-direction="row"] { flex-direction: var(--flow-flex-direction-inverse); align-items: flex-start; } .responsive-flex-layout[data-direction="column"] { flex-direction: var(--flow-flex-direction); align-items: center; } @media(min-width: 992px) { .responsive-flex-layout[data-direction="row"][data-auto-align="true"] { align-items: center; } .responsive-flex-layout[data-direction="column"][data-auto-align="true"] { align-items: flex-start; } }</style><style>.nav-section .nav-item:first-child { padding: 0; } .nav-section .nav-item { padding-left: 20px; } .nav-section .nav-title { font-weight: bold; text-decoration: underline; } @media(min-width: 992px) { .nav-section .nav-item { padding-left: 0; padding-top: 20px; } .nav-section .nav-section-layout { align-items: stretch; } }</style><style>.island { padding: var(--flow-padding); } .island-content { padding: var(--flow-padding); box-shadow: 3px 3px 7px 1px var(--color-bg-shadow); border: 1px solid var(--color-bg-shadow); border-radius: 5px; }</style><style>.page-section { padding-top: var(--flow-padding); } .page-section:first-of-type { padding-top: 0; }</style><style>code.code-block.cb-inline { display: inline-block; } code.code-block.cb-block { display: block; width: 100%; padding: 2px 0; } code.code-block > textarea { background-color: #F9F9EF; color: var(--color-secondary); border: 1px solid var(--color-bg-shadow); margin: 0; padding: 3px; font-family: "Lucida Console", Monaco, monospace; resize: none; overflow: hidden; width: 100%; } code.code-block.cb-block > textarea { resize: both; } code.code-block.cb-scroll-x > textarea, code.code-block.cb-scroll-both > textarea { overflow-x: auto; } code.code-block.cb-scroll-y > textarea, code.code-block.cb-scroll-both > textarea { overflow-y: auto; }</style><style>#main-layout { display: flex; flex-direction: column; flex-wrap: nowrap; justify-content: stretch; } #top-bar { display: flex; flex-direction: row; flex-wrap: nowrap; align-items: center; padding: var(--flow-padding); background-color: var(--color-bg-banner); flex: 1 0 100%; } #lower-section { background-color: var(--color-bg-content); box-shadow: inset 0 8px 5px -5px var(--color-bg-banner); display: flex; flex-direction: row; flex-wrap: wrap; justify-content: stretch; } #main-content { padding: var(--flow-padding); flex: 1; } #main-content-header { padding-bottom: var(--flow-padding); } #side-bar { flex: 1 0 100%; } @media(min-width: 992px) { #side-bar { flex: 0 0 300px; } }</style></head><body><div id="main-layout"><header id="top-bar"><h1 id="page-title">Getting Started - JS API</h1><div class="flex-spacer"></div></header><div class="responsive-flex-layout" id="lower-section" data-direction="row" data-auto-align="false"><aside id="side-bar"><div class="island"><div class="island-content"><nav class="site-nav"><nav class="nav-section"><div class="responsive-flex-layout nav-section-layout" data-direction="column" data-auto-align="false"><div class="nav-item"><a href="../../index.html">Home</a></div><div class="nav-item"><a href="../../sections/gettingStarted/home.html" class="link-is-current-page">Getting Started</a></div><div class="nav-item"><a href="../../gen/typedoc/index.html" target="_blank" rel="noopener">API Documentation</a></div></div></nav></nav></div></div><div class="island"><div class="island-content"><nav class="nav-section"><div class="responsive-flex-layout nav-section-layout" data-direction="column" data-auto-align="false"><div class="nav-item"><a href="../../sections/gettingStarted/home.html">Getting Started - Home</a></div><div class="nav-item"><a href="../../sections/gettingStarted/installation.html">Getting Started - Installation</a></div><div class="nav-item"><a href="../../sections/gettingStarted/htmlUsage.html">Getting Started - HTML Usage</a></div><div class="nav-item"><a href="../../sections/gettingStarted/cli.html">Getting Started - CLI</a></div><div class="nav-item"><a href="../../sections/gettingStarted/api.html" class="link-is-current-page">Getting Started - JS API</a></div></div></nav></div></div></aside><main id="main-content"><header id="main-content-header"><h2>API Usage</h2></header><section class="page-section"><p>This section describes the basic usage and functionality of the Mooltipage JavaScript API. The JS API is an advanced interface, and the information on this page assumes a background knowledge of JavaScript and Node.JS. Additionally, this guide does not explain the basic concepts and features of Mooltipage. It is recommended to review the CLI documentation even if you intend to use only the API. You will also need an editor capable of working with JavaScript. A basic text editor like Notepad will work, but a full editor such as VS Code is recommended.</p></section><section class="page-section"><header><h5>Creating a build script:</h5></header><p>If you followed the recommended setup in the installation section, then you have a basic npm project with Mooltipage installed. The next step is to create a "build" script that will be called by Node.JS to compile your project. This script will be responsible for loading, configuring, and invoking Mooltipage. For a basic general-purpose build script, follow these steps:</p><ol><li>First, we need to create the build script file. Create a file call "build.js" in the root of your project. It can be moved later if you prefer to structure your project differently.</li><li>Next, open the new file in an editor. Add this line to the top of the file: <code class="code-block language-javascript cb-block cb-scroll-off"><textarea readonly spellcheck="false" rows="3">const { Mooltipage } from 'mooltipage';</textarea></code> This will instruct Node.JS to load the main Mooltipage API constructor, and save it to the local constant Mooltipage.</li><li>Mooltipage is loaded, but we need an instance before we can use it. To create an instance, we call the Mooltipage() construct and pass it a configuration object. Create a configuration object like this: <code class="code-block language-javascript cb-block cb-scroll-off"><textarea readonly spellcheck="false" rows="3">const mooltipageConfig = { inPath: './src/', outPath: './dist/', formatter: 'pretty' };</textarea></code> With this config object, Mooltipage will be configured to load inputs from "./src" and save them to "./dist". Additionally, HTML outputs will be formatted with the "pretty" HTML formatter. For more details on these properties and their effects, see the CLI usage section.</li><li>Now that we have loaded Mooltipage and have prepared a config object, we can create a Mooltipage instance. We create an instance by invoking the Mooltipage constructor. Add this code to your build script: <code class="code-block language-javascript cb-block cb-scroll-off"><textarea readonly spellcheck="false" rows="3">const mp = new Mooltipage(mooltipageConfig);</textarea></code> This instance is immediately ready to use and can be reused for as many pages as desired.</li></ol><p>At this point, the build script should look like this (comments added for clarity): <code class="code-block language-javascript cb-block cb-scroll-off"><textarea readonly spellcheck="false" rows="3">// import and load mooltipage const { Mooltipage } from 'mooltipage'; // prepare mooltipage config object const mooltipageConfig = { // load inputs from "./src" folder inPath: './src/', // save outputs to "./dist" folder outPath: './dist/ // format output HTML for human readability formatter: 'pretty' }; // create mooltipage instance const mp = new Mooltipage(mooltipageConfig);</textarea></code> This script is almost done. Mooltipage is loaded, configured, and ready to start compiling pages. All that is left is to tell Mooltipage which files to process.</p></section><section class="page-section"><header><h5>Building a single page:</h5></header><p>Building a single page is very easy. You simply invoke the processPage function with the path to file. The default compilation pipeline will load, compile, and save the file automatically. Simple usage looks like this: <code class="code-block language-javascript cb-block cb-scroll-off"><textarea readonly spellcheck="false" rows="3">mp.processPage('./index.html');</textarea></code> All compilation settings, like the input / output paths and selected formatter, are taken from the configuration values provided earlier. If you need to compile a page with different settings, then you can create another Mooltipage instance with new configuration data. The instances are completely isolated and will not conflict.</p></section><section class="page-section"><header><h5>Building multiple pages:</h5></header><p>Compiling a single page is useful, but most projects will include more than one page. The obvious way to compile multiple pages is to call processPage multiple times, like this: <code class="code-block language-javascript cb-block cb-scroll-off"><textarea readonly spellcheck="false" rows="3">mp.processPage('./index.html'); mp.processPage('./pages/page1.html'); mp.processPage('./pages/page2.html');</textarea></code> This will work, but there is a better way. In addition to processPage, the Mooltipage API also exposes the processPages function which compiles multiple pages at once. Simply pass in an array containing paths to all of the pages that you want to compile, and they will all be compiled sequentially. The above example can be simplified to: <code class="code-block language-javascript cb-block cb-scroll-off"><textarea readonly spellcheck="false" rows="3">const pagePaths = [ './index.html', './pages/page1.html', './pages/page2.html' ]; mp.processPages(pagePaths);</textarea></code></p></section><section class="page-section"><header><h5>Advanced Usage - Using different options for a page:</h5></header><p>All of the examples so far have only emulated functionality that is already available through the CLI. The API, however, is capable of more. This and the following sections will demo functionality that is only available through the API. If you have followed all the previous sections, then your build script should look something like this (comments added for clarity): <code class="code-block language-javascript cb-block cb-scroll-off"><textarea readonly spellcheck="false" rows="3">// import and load mooltipage const { Mooltipage } from 'mooltipage'; // prepare mooltipage config object const mooltipageConfig = { // load inputs from "./src" folder inPath: './src/', // save outputs to "./dist" folder outPath: './dist/ // format output HTML for human readability formatter: 'pretty' }; // create mooltipage instance const mp = new Mooltipage(mooltipageConfig); // list pages to compiled const pagePaths = [ './index.html', './pages/page1.html', './pages/page2.html' ]; // compile all pages mp.processPages(pagePaths);</textarea></code> This build script is perfectly usable, but it does nothing that the CLI can't already do. To make it actually useful, lets add support for a special page where HTML formatting must be disabled. To do this with the CLI, multiple commands are required. With the API, however, there is no such limitation. Add the following to the script: <code class="code-block language-javascript cb-block cb-scroll-off"><textarea readonly spellcheck="false" rows="3">const mooltipageConfigNoFormat = { inPath: './src/', outPath: './dist/ formatter: 'none' }; const mpNoFormat = new Mooltipage(mooltipageConfigNoFormat); mpNoFormat.processPage('./pages/special.html');</textarea></code> This code will instruct Mooltipage to compile special.html without an HTML formatter, while the other pages still compile in pretty mode. Unfortunately, this is not very compact. An additional seven lines of code for one just one page is somewhat excessive. To mitigate that, we can rework the script a bit. Change the script to look like this: <code class="code-block language-javascript cb-block cb-scroll-off"><textarea readonly spellcheck="false" rows="3">const { Mooltipage } from 'mooltipage'; // create base config object const baseConfig = { inPath: './src/', outPath: './dist/',. formatter: 'pretty' }; // create mooltipage instances const mp = new Mooltipage(baseConfig); const mpSpecial = new Mooltipage(Object.assign(Object.create(baseConfig), { formatter: 'none' }); // compile pages mp.processPages([ './index.html', './pages/page1.html', './pages/page2.html' ]); mpSpecial.processPage('./pages/special.html');</textarea></code> This version is smaller and more extensible. This works by creating a single "base" configuration object that holds settings common to all configurations used. The main "mp" instance uses this directly, while the mpSpecial instance extends baseConfig and overrides the "formatter" property to none. If additional special compilation modes are needed, then adding them is as simple as duplicating the "new Mooltipage" block and modifying the configuration overrides.</p></section><section class="page-section"><header><h5>Advanced Usage - Building pages dynamically:</h5></header><p>One of the most useful benefits of the API interface is that it enables dynamic calls into Mooltipage. Both processPage and processPages can be called multiple times - even from within loops or other functions. This makes it possible to selectively include or exclude a page based on some factor external to Mooltipage. For an example, lets assume that we have a "debug.html" that should only be included in non-production builds. We can use the NODE_ENV environment variable to check if this is a production build. To support this, add the following to the build script: <code class="code-block language-javascript cb-block cb-scroll-off"><textarea readonly spellcheck="false" rows="3">const isProduction = process.env.NODE_ENV === 'production'; if (!isProduction) { mp.processPage('./pages/debug.html'); }</textarea></code> With this code, debug.html will only be included if Node.JS is NOT running in production mode.</p><p>The API's dynamic functionality is not limited to just pages that are known about in advance. It is possible to build an arbitrary number of pages with any filenames and content. As an example, lets extend the build script to accept a list of pages from the command line. In a real-world application, these could be the paths to semi-compiled HTML artifacts produced by an earlier build process. This feature could be implemented like this: <code class="code-block language-javascript cb-block cb-scroll-off"><textarea readonly spellcheck="false" rows="3">const pages = process.argv.slice(2); for (const page of pages) { mp.processPage(page); }</textarea></code> This will compile any number - including zero - of extra pages passed in via the command line.</p></section><section class="page-section"><header><h5>Advanced Usage - Getting feedback:</h5></header><p>If you've been following all previous sections, then your build script should look like this (with tweaks to minimize boilerplate): <code class="code-block language-javascript cb-block cb-scroll-off"><textarea readonly spellcheck="false" rows="3">const { Mooltipage } from 'mooltipage'; // create base config object const baseConfig = { inPath: './src/', outPath: './dist/', formatter: 'pretty' }; // create mooltipage instances const mp = new Mooltipage(baseConfig); const mpSpecial = new Mooltipage(Object.assign(Object.create(baseConfig), { formatter: 'none' }); // compile pages mp.processPages([ './index.html', './pages/page1.html', './pages/page2.html' ]); mpSpecial.processPage('./pages/special.html'); // compile debug page if not in production if (process.env.NODE_ENV !== 'production') { mp.processPage('./pages/debug.html'); } // compile extra pages from CLI mp.processPages(process.argv.slice(2));</textarea></code> This is a pretty powerful build script. It supports compiling pages with differing settings, optionally including pages based on environment, and dynamic pages from external sources. But if were to run it, you would notice right away that something is missing. This script includes no feedback, progress, or any output at all! For hardcoded page paths, it is simple to add console.log statements to print progress. But that wont work for processPages, where multiple pages are passed at once. Fortunately, the API accepts a callback that will be invoked whenever a page is compiled. You can attach a callback to the config object using one of these syntaxes: <code class="code-block language-javascript cb-block cb-scroll-off"><textarea readonly spellcheck="false" rows="3">// Option 1 const config = { onPageCompiled: (page) => console.log(`Compiled \${ page.path }`); } // Option 2 function pageCompiledCallback(page) { console.log(`Compiled \${ page.path }`) } const config = { onPageCompiled: pageCompiledCallback }</textarea></code> For this sample build script, we will use Option 1 due to its smaller size. Add the onPageCompiled callback to the baseConfig object, and the build script should look like this: <code class="code-block language-javascript cb-block cb-scroll-off"><textarea readonly spellcheck="false" rows="3">const { Mooltipage } from 'mooltipage'; // create base config object const baseConfig = { inPath: './src/', outPath: './dist/', formatter: 'pretty', onPageCompiled: (page) => console.log(`Compiled \${ page.path }`); }; // create mooltipage instances const mp = new Mooltipage(baseConfig); const mpSpecial = new Mooltipage(Object.assign(Object.create(baseConfig), { formatter: 'none' }); // compile pages mp.processPages([ './index.html', './pages/page1.html', './pages/page2.html' ]); mpSpecial.processPage('./pages/special.html'); // compile debug page if not in production if (process.env.NODE_ENV !== 'production') { mp.processPage('./pages/debug.html'); } // compile extra pages from CLI mp.processPages(process.argv.slice(2));</textarea></code> With this change, the build script will now print out a status line each time a page is compiled. We won't be using them in this example script, but the page object provided to the callback has more properties than just "path". The definition for that object (in TypeScript) is: <code class="code-block language-typescript cb-block cb-scroll-off"><textarea readonly spellcheck="false" rows="3">interface Page { // Path to the file (relative to inPath) readonly path: string; // Root of the Document Object Model (DOM) tree representing the page, can be used to examine the output readonly dom: DocumentNode; // Formatted HTML output of the compiled page readonly html: string; }</textarea></code> For some advanced situations, it can be useful to be able to programmatically example the compiled output. The "dom" and "html" properties are exposed for that purpose. Be aware, however, that the onPageCompiled callback is called *after* the page is saved. Changes here will have no effect on the compiled output.</p></section><section class="page-section"><header><h5>Advanced Usage - Extending the pipeline:</h5></header><p>TODO: example of adding a loosely-integrated &lt;if-debug> custom element</p></section></main></div></div></body></html>